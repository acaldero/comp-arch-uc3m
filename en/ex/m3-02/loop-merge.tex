\begin{acexercise}\end{acexercise}


Consider the following code fragment:

\begin{lstlisting}
double a[256][256], b[256][256], c[256][256], d[256][256];
//...
for (int i=0;i<256;++i)
  for (int j=0;j<256;++j) {
    a[i][j] = b[i][j] + c[i][j]
  }
}
for (int i=0;i<256;++i)
  for (int j=0;j<256;++j) {
    d[i][j] = b[i][j] - c[i][j]
  }
}
\end{lstlisting}

We want to run this code in a computer with fully associative 16 KB level 1
cache. Replacement policy is LRU with a 64 bytes line size. Level 1 cache misses
require 16 clock cycles. Besides, level 2 cache always gives hits for this code.

Assume that write misses in level 1 cache are directly sent to a write buffer
and do not generate stall cycles.

You are asked:

\begin{enumerate}
  \item Determine the hit rate for the code segment, assuming that variables
        \cppid{i} and \cppid{j} are assigned to processor registers and that 
        matrices \cppid{a}, \cppid{b}, \cppid{c} and \cppid{d} fully reside at
        level 2 cache.

  \item Determine the memory access time assuming that accesses to level 1 cache
        require a clock cycle.

  \item Propose a code transformation that can be generated by a compiler to
        improve hit rate, showing the resulting code in the C programming
        language.

  \item Determine the new hit rate and the resulting average access time to
        memory.

\end{enumerate}


\begin{acsolution}\end{acsolution}

\paragraph{Point 1}

Due to the line size, 64 bytes, and that all arrays contain values of type 
\cppkey{double}, each line of the cache can store 8 values. Since the L1 
cache has a size of 16 KB, we can store $\frac{2^{14}}{2^6} = 2^8$ lines.

Each array stores $2^8 \dot 2^8 = 2^{16}$ elements, which requires 
$\frac{2^{16}}{2^3} = 2^{13}$ entries in the cache.

In the first loop, the access pattern is:

\begin{itemize}
  \item \cppid{b[0][0]}, \cppid{c[0][0]}, \cppid{a[0][0]}
  \item \cppid{b[0][1]}, \cppid{c[0][1]}, \cppid{a[0][1]}
  \item \ldots
  \item \cppid{b[0][7]}, \cppid{c[0][7]}, \cppid{a[0][7]}
  \item \cppid{b[0][8]}, \cppid{c[0][8]}, \cppid{a[0][8]}
  \item \ldots
  \item \cppid{b[0][255]}, \cppid{c[0][255]}, \cppid{a[0][255]}
  \item \cppid{b[1][0]}, \cppid{c[1][0]}, \cppid{a[1][0]}
  \item \ldots
\end{itemize}

Therefore, for every 8 iterations of the inner loop:

\begin{itemize}
  \item 16 reads (8 for \cppid{b} and 8 for \cppid{c}). Of these, 2 are misses and the other 14 are hits.
  \item 8 writes in \cppid{a}. However, when writes are sent to the buffer, they do not generate misses.
\end{itemize}

When the second loop is started, the cache entries containing the values of the arrays \cppid{b} 
and \cppid{c} have been flushed from the cache, so the miss and hit ratios are the same.

In the case of writes, all writes generate cache misses. So:


\[
h_{write} = 0
\]

In case of reads, the hit rate is:

\[
h_{read}  = \frac{14}{16} = \frac{7}{8}
\]

\paragraph{Point 2}

For write accesses, all accesses are a write misses and are handled in the write buffer, requiring 
a clock cycle. In total, $2^8 \cdot 2^8$ accesses are made in each of the two loops, resulting in a 
total of $2 \cdot 2^{16} = 2^{17}$ write accesses.


For read access, the average access time is represented by:

\[
t_{read} = t_a + (1 - h_{read}) \cdot t_f
\]

The access time $ t_a $ is 1 cycle. The penalty for reading failures is 16 cycles. 
Therefore, we have that the average reading time is:

\[
t_{read} =
1 + \frac{1}{8} \cdot 16 = 
3
\]

\paragraph{Point 3}

The merging-loop technique can be applied:

\begin{lstlisting}
for (int i=0;i<256;i++) {
  for (int j=0;j<256;j++) {
    a[i][j] = b[i][j] + c[i][j];
    d[i][j] = b[i][j] - c[i][j];
  }
}
\end{lstlisting}

\paragraph{Point 4}

In this case, the second accesses to \cppid{b} and \cppid{c} always generate hits.

Now, for every 8 iterations of the inner loop:

\begin{itemize}
  \item 32 read. From them, 30 are hits and two are read misses.
  \item 16 writes.
\end{itemize}

As in the previous case, the writing hit rate  ($h_{escr}$) remains 0. In this case, the reading hit rate is:

\[
h_{read} = \frac{30}{32} = \frac{15}{16}
\]

For the case of reads, using the new  hit rate, we obtain that:

\[
t_{read} =
1 + \frac{1}{16} \cdot 16 = 
2
\]

