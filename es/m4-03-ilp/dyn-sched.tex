\section{Introducción a la planificación dinámica}
\begin{frame}[t]{Planificación dinámica}
\begin{itemize}
  \item El hardware \textgood{reordena} la ejecución de instrucciones para
        \textmark{reducir} detenciones manteniendo el comportamiento de flujo de
        datos y excepciones.

  \mode<presentation>{\vfill\pause}
  \item \textgood{Ventajas}:
    \begin{itemize}
      \item Código compilado optimizado para un pipeline ejecuta eficientemente 
            en otro pipeline.
        \begin{itemize}
          \item Simplificación del compilador.
        \end{itemize}
      \item Gestiona dependencias desconocidas en tiempo de compilación.
      \item Permite tolerar retrasos no predecibles en tiempo de compilación
            (ej. Fallo de caché).
    \end{itemize}

  \mode<presentation>{\vfill\pause}
  \item \textbad{Desventaja}:
    \begin{itemize}
      \item Mayor complejidad del hardware.
    \end{itemize}

  \mode<presentation>{\vfill\pause}
  \item Permite la \textmark{especulación hardware}.

\end{itemize}
\end{frame}


\begin{frame}[t]{Planificación dinámica}
\begin{itemize}
  \item \textgood{Efectos}:
    \begin{itemize}
      \item Ejecución fuera de orden (OoO).
      \item Finalización fuera de orden.
      \item Puede introducir \textbad{riesgos} WAR y WAW.
    \end{itemize}

  \mode<presentation>{\vfill\pause}
  \item Separación de etapa \textgood{ID} en \textmark{dos etapas}:
    \begin{itemize}
      \item \textmark{Emisión}: Decodifica la instrucción y comprueba riesgos estructurales.
      \item \textmark{Lectura de operandos}: Espera hasta que no haya riesgos de datos y lee operandos.
    \end{itemize}

  \mode<presentation>{\vfill\pause}
  \item \textmark{Etapa de captación} (\textgood{IF}):
    \begin{itemize}
      \item Capta en registro de instrucciones o cola de instrucciones.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t]{Ideas de la planificación dinámica}
  \begin{enumerate}
    \item \textbad{Lee} la sección \textmark{3.4} --
          Overcoming Data Hazards with Dynamic Scheduling.
          \textbad{Solamente} la subsección \emph{Dynamic Scheduling: The idea}
          (pág. 193--195).
      \begin{itemize}
        \item \bibhennessy
      \end{itemize}

    \mode<presentation>{\vfill}
    \item \textgood{Aspectos clave}:
      \begin{itemize}
        \item ¿Cuál es la diferencia entre orden de emisión y orden de ejecución?
        \item ¿Por qué la ejecución fuera de orden introduce nuevos riesgos de datos? ¿Cuáles?
        \item ¿Cuáles son las interacciones entre finalización fuera de orden y las excepciones hardware?
        \item ¿Qué es una excepción imprecisa?
        \item ¿Cuáles son los requisitos derivados de tener múltiples instrucciones en ejecución?
      \end{itemize}
  \end{enumerate}
\end{frame}


\begin{frame}[t]{Técnicas de planificación dinámica}
\begin{itemize}
  \item \textmark{Scoreboard}:
    \begin{itemize}
      \item Detiene instrucciones emitidas hasta que hay recursos suficientes y no hay riesgos de datos.
      \item Ejemplos: CDC 6600, ARM A8.
    \end{itemize}

  \mode<presentation>{\vfill}
  \item \textmark{Algoritmo de Tomasulo}:
    \begin{itemize}
      \item Elimina dependencias WAR y WAW con renombrado de registros.
      \item Ejemplos: IBM 360, Intel Core i7.
    \end{itemize}
\end{itemize}
\end{frame}
